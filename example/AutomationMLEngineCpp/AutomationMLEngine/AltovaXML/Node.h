////////////////////////////////////////////////////////////////////////
//
// Node.h
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_NODE_H_INCLUDED
#define ALTOVA_NODE_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include "AltovaXMLAPI.h"
#include "../Altova/xs-types.h"


class ALTOVAXML_DECLSPECIFIER XercesTreeOperations
{
public:

	static void CopyAll(const xercesc::DOMNode* src, xercesc::DOMNode* tgt);

	class AllIterator
	{
		xercesc::DOMNode* m_Current;
	public:
		operator bool() const { return m_Current != 0; }
		bool operator++() { m_Current = m_Current->getNextSibling(); return m_Current != 0; }
		bool operator--() { m_Current = m_Current->getPreviousSibling(); return m_Current != 0; }
		xercesc::DOMNode* operator*() const { return m_Current; }

		AllIterator( xercesc::DOMNode* start ) : m_Current( start ) {}
	};

	class MemberIterator
	{
		AllIterator m_AllIterator;
		const altova::MemberInfo* m_MemberInfo;

	public:
		operator bool() const { return m_AllIterator; }

		bool operator++()
		{
			while (++m_AllIterator)
			{
				if (IsMember(*m_AllIterator, m_MemberInfo))
					return true;
			}
			return false;
		}

		bool operator--()
		{
			while (--m_AllIterator)
			{
				if (IsMember(*m_AllIterator, m_MemberInfo))
					return true;
			}
			return false;
		}

		xercesc::DOMNode* operator*() const { return *m_AllIterator; }

		MemberIterator(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo)
			: m_AllIterator( pNode ), m_MemberInfo( pMemberInfo )
		{
			while (m_AllIterator && !IsMember(*m_AllIterator, m_MemberInfo))
				++m_AllIterator;
		}
	};

	static bool IsEqualString(const XMLCh* a, const char_type* b);
	static bool IsMember(xercesc::DOMNode* pNode, const altova::MemberInfo* pMember);
	static bool IsValid(xercesc::DOMNode*  pNode);
	static AllIterator GetElements(xercesc::DOMNode* pNode);
	static MemberIterator GetElements(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static void SetTextValue(xercesc::DOMNode* pNode, const string_type& sText);
	static string_type GetTextValue(xercesc::DOMNode* pNode);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const XMLCh* sValue);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const string_type& sValue);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, bool b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, int b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, unsigned b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, __int64 b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, unsigned __int64 b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, double b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, altova::DateTime b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, altova::Duration b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const std::vector<unsigned char>& b);
	static void SetValue(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo, const xercesc::DOMNode* b);
	static xercesc::DOMNode* AddElement(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
    static xercesc::DOMNode* CreateElement(xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);

	static double CastToDouble(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static string_type CastToString(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static __int64 CastToInt64(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static unsigned __int64 CastToUInt64(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static unsigned CastToUInt(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static int CastToInt(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static bool CastToBool(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static altova::DateTime CastToDateTime(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static altova::Duration CastToDuration(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);
	static std::vector<unsigned char> CastToBinary(const xercesc::DOMNode* pNode, const altova::MemberInfo* pMemberInfo);

	static xercesc::DOMNode* FindAttribute(xercesc::DOMNode* pNode, const altova::MemberInfo* member);

	static xercesc::DOMNode* GetParent(xercesc::DOMNode* pNode);
	static void SetValue(xercesc::DOMNode* pNode, const string_type& sValue);
	static void RemoveAttribute(xercesc::DOMNode* pNode, const altova::MemberInfo* member);
	static void RemoveElements(xercesc::DOMNode* pNode, const altova::MemberInfo* member);
	static void RemoveElement(xercesc::DOMNode* pNode, const altova::MemberInfo* member, unsigned index);

	typedef xercesc::DOMDocument* DocumentType;

	static DocumentType LoadDocument(const string_type& filename);
	static void FreeDocument(DocumentType& document);
	static void SaveDocument( const DocumentType& document, const string_type& filename, bool prettyPrint );
	static void SaveDocument( const DocumentType& document, const string_type& filename, bool prettyPrint, const string_type& encoding, bool bBigEndian, bool bBOM );

	static DocumentType LoadXml(const string_type& xml);
	static DocumentType LoadFromBinary(const std::vector<unsigned char>& binary);
	static string_type SaveXml(const DocumentType& document, bool prettyPrint);
	static std::vector<unsigned char> SaveToBinary(const DocumentType& document, bool prettyPrint);
	static void SaveToBinary( std::vector<unsigned char>& result, const DocumentType& document, bool prettyPrint, const string_type& encoding, bool bBigEndian, bool bBOM, bool bIncludeEncoding = true );

	static DocumentType CreateDocument();

	static void AddProcessingInstruction(xercesc::DOMNode* node, const string_type& target, const string_type& value);

	static void SetAttribute(xercesc::DOMNode* node, const string_type& localName, const string_type& namespaceURI, const string_type& value);

protected:
	static void CorrectByteOrderAndBOM( std::vector<unsigned char>& bytes, const string_type& encoding, bool bBigEndian, bool bBOM );
	static int GetEncodingAndByteOrderFromXml( std::vector<unsigned char>& sourceBytes );
	static int GetEncodingAndByteOrderFromXml( unsigned char* sourceBytes, int sourceLength );
	static int GetUnicodeSizeFromEncodingName( const string_type& encodingIn );
	static string_type Uppercase( const string_type& str );
};


namespace altova {

class ALTOVAXML_DECLSPECIFIER CNode : public CBaseObject
{
public:
	typedef enum
	{
		Element,
		Attribute,
		Text,
		CData,
		Comment,
		ProcessingInstruction
	} ENodeType;

	typedef enum
	{
		eSequence,
		eAll,
		eChoice
	} EGroupType;

protected:
	CNode();
	CNode(xercesc::DOMNode* pThisNode);
	CNode(xercesc::DOMDocument* pDOMDocument);
	virtual ~CNode();

public:
	CNode& 					Assign(const CNode& other);
	CNode& 					CopyOf(const CNode& other);
	tstring					GetNodeName();
	tstring					GetNodeValue();
	xercesc::DOMNode*		GetDOMNode();
	//EGroupType				GetGroupType() const = 0;
	void					MapPrefix(const tstring& sPrefix, const tstring& sURI);
	static bool				NamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName);
	static tstring			GetNodeTextValue( xercesc::DOMNode* pNode );

protected:
	friend class CDoc;

	tstring					InternalGetElementValue();
	void					InternalSetElementValue(const tstring& sValue);
	static bool				InternalNamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName);

	int						ChildCountInternal(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	bool					InternalHasChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	xercesc::DOMNode*		InternalCreate(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue);
	xercesc::DOMNode*		InternalAppend(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue);
	xercesc::DOMNode*		InternalAppendNode(const tstring& sNamespaceURI, const tstring& sName, CNode& rNode);
	xercesc::DOMNode*		InternalGetAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex);
	xercesc::DOMNode* 		InternalGetFirstChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	xercesc::DOMNode* 		InternalGetNextChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, xercesc::DOMNode* pCurNode );

	xercesc::DOMNode*		InternalGet(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName);
	xercesc::DOMNode*		InternalInsertAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue);
	xercesc::DOMNode*		InternalInsertNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode);
	xercesc::DOMNode*		InternalReplaceAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue);
	xercesc::DOMNode*		InternalReplaceNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode);
	xercesc::DOMNode*		InternalRemoveAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex);

	xercesc::DOMElement*	InternalAdopt(xercesc::DOMNode* pElement, const tstring& sNamespaceURI, const tstring& sName);
	static void				DeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI);
	static void				InternalDeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI);
	static const XMLCh*		LookupPrefix(xercesc::DOMNode* pNode, const XMLCh* szURI);
	void InternalSetAttribute( const tstring& sName, const tstring& sNamespaceURI, const tstring& sValue);
	static xercesc::DOMNode* LookupDefaultNamespace(xercesc::DOMNode* pDOMNode);
	static void				InternalAdjustPrefix(xercesc::DOMNode* pDOMNode, bool bQualified);
	virtual void			AdjustPrefix() = 0;

	xercesc::DOMNode*		m_pDOMNode;
};


class CSchemaString;

class ALTOVAXML_DECLSPECIFIER CAnyTypeNode : public CNode
{
public:
	CAnyTypeNode() : CNode() {}
	CAnyTypeNode(xercesc::DOMNode* pThisNode) : CNode(pThisNode) {}
	CAnyTypeNode(xercesc::DOMDocument* pDoc) : CNode(pDoc) {}
	virtual ~CAnyTypeNode() {}

	CAnyTypeNode(const CSchemaString &Value);
	CAnyTypeNode& operator =(const CSchemaString& Value);
	void Assign(const CSchemaString& Value);
	virtual operator CSchemaString();
	static EGroupType GetGroupType();
	void AdjustPrefix();


	void AddTextNode(CSchemaString text);
	void AddCDataNode(CSchemaString text);
	void AddComment(CSchemaString text);
	void AddProcessingInstruction(CSchemaString name, CSchemaString text);
};

} // namespace altova


#endif // ALTOVA_NODE_H_INCLUDED
