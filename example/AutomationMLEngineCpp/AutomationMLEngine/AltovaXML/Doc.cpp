////////////////////////////////////////////////////////////////////////
//
// Doc.cpp
//
// This file was generated by XMLSpy 2008 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "../Altova/Altova.h"
#include "../Altova/SchemaTypes.h"
#include "XmlException.h"
#include "Node.h"
#include "Doc.h"
#include <xercesc/framework/MemBufInputSource.hpp>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xercesc/framework/MemBufFormatTarget.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include "../Altova/exception.h"

#define X(str) XStr(str).unicodeForm()

namespace altova {


xercesc::DOMImplementation*		CDoc::sm_ImplementationCore	= NULL;
xercesc::DOMImplementationLS*	CDoc::sm_ImplementationLS	= NULL;
xercesc::DOMBuilder*			CDoc::sm_Builder			= NULL;
xercesc::DOMWriter*				CDoc::sm_Writer				= NULL;
xercesc::DOMDocument*			CDoc::sm_Document			= NULL;
xercesc::DOMDocumentFragment*	CDoc::sm_Fragment			= NULL;
int								CDoc::sm_nTmpNameCounter	= 0;
int								CDoc::sm_nFragmentCounter	= 0;
int								CDoc::sm_nBuilderCounter	= 0;
int								CDoc::sm_nWriterCounter		= 0;
bool							CDoc::sm_bValidation		= false;


void CDoc::EnableValidation(bool bValidation)
{
	sm_bValidation = bValidation;
}


xercesc::DOMImplementation* CDoc::GetImplementationCore()
{
	if (sm_ImplementationCore == NULL)
	{
		sm_ImplementationCore =
				xercesc::DOMImplementationRegistry::getDOMImplementation(X("Core"));

		if (sm_ImplementationCore == NULL)
			CXmlException(1, _T("Could not create xercesc::DOMImplementation"));
	}

	return sm_ImplementationCore;
}


xercesc::DOMImplementationLS* CDoc::GetImplementationLS()
{
	if (sm_ImplementationLS == NULL)
	{
		sm_ImplementationLS = static_cast<xercesc::DOMImplementationLS*>(
				xercesc::DOMImplementationRegistry::getDOMImplementation(X("LS"))
				);

		if (sm_ImplementationLS == NULL)
			throw CXmlException(1, _T("Could not create xercesc::DOMImplementationLS"));
	}

	return sm_ImplementationLS;
}


xercesc::DOMBuilder* CDoc::GetBuilder()
{
	if (sm_Builder == NULL)
	{
		sm_Builder = GetImplementationLS()->createDOMBuilder(
				xercesc::DOMImplementationLS::MODE_SYNCHRONOUS,
				0
				);

		if (sm_Builder == NULL)
			throw CXmlException(1, _T("Could not create xercesc::DOMBuilder"));

		sm_Builder->setFeature(xercesc::XMLUni::fgDOMNamespaces, true);
		if (sm_bValidation)
		{
			sm_Builder->setFeature(xercesc::XMLUni::fgDOMValidation, true);
			sm_Builder->setFeature(xercesc::XMLUni::fgXercesSchema, true);
		}
	}
	if (!m_bBuilder)
	{
		sm_nBuilderCounter++;
		m_bBuilder = true;
	}

	return sm_Builder;
}


xercesc::DOMWriter* CDoc::GetWriter()
{
	if (sm_Writer == NULL)
	{
		sm_Writer = GetImplementationLS()->createDOMWriter();

		if (sm_Writer == NULL)
			throw CXmlException(1, _T("Could not create xercesc::DOMWriter"));
	}
	if (!m_bWriter)
	{
		sm_nWriterCounter++;
		m_bWriter = true;
	}

	return sm_Writer;
}


xercesc::DOMDocument* CDoc::GetDocument()
{
	if (sm_Document == NULL)
	{
		sm_Document = GetImplementationCore()->createDocument();
	}
	return sm_Document;
}


xercesc::DOMNode* CDoc::CreateFragment()
{
	char szNumber[32] = "tmp";
	_itoa(sm_nTmpNameCounter++, szNumber + 3, 10);
	sm_nFragmentCounter++;

	if (sm_Fragment == NULL)
	{
		sm_Fragment = GetDocument()->createDocumentFragment();
		if (sm_Fragment == NULL)
			throw CXmlException(1, _T("Could not create fragment"));
	}
	xercesc::DOMNode* pNode = GetDocument()->createElement(X(szNumber));
	sm_Fragment->appendChild(pNode);
	return pNode;
}


void CDoc::ReleaseFragment(xercesc::DOMNode* pDOMNode)
{
	if (pDOMNode != NULL && pDOMNode->getParentNode() != NULL)
	{
		if (pDOMNode->getParentNode()->getNodeType() == xercesc::DOMNode::DOCUMENT_FRAGMENT_NODE)
			sm_nFragmentCounter--;
	}
}


bool CDoc::InternalErrorHandler::handleError(const xercesc::DOMError& domError)
{
	m_sErrors += XC2TS(domError.getMessage());
	m_sErrors += _T("\n");
	return true; // continue
}


void CDoc::InternalErrorHandler::ReportErrors() const
{
	if (!m_sErrors.empty())
		throw CXmlException(1, m_sErrors);
}


CDoc::CDoc() : m_eSchemaType(None), m_bBuilder(false), m_bWriter(false)
{
}


CDoc::~CDoc()
{
	if (sm_nFragmentCounter == 0)
	{
		delete sm_Document;
		sm_Document = NULL;
		sm_Fragment = NULL;
	}
	if (m_bBuilder)
	{
		if (--sm_nBuilderCounter <= 0)
		{
			delete sm_Builder;
			sm_Builder = NULL;
		}
	}
	if (m_bWriter)
	{
		if (--sm_nWriterCounter <= 0)
		{
			delete sm_Writer;
			sm_Writer = NULL;
		}
	}
}


xercesc::DOMDocument* CDoc::Load(const tstring& sURI)
{
	xercesc::DOMBuilder* pBuilder = GetBuilder();
	InternalErrorHandler oErrorHandler;
	pBuilder->setErrorHandler(&oErrorHandler);
	xercesc::DOMDocument* pDoc = pBuilder->parseURI(X(sURI));
	pBuilder->setErrorHandler(NULL);
	oErrorHandler.ReportErrors();
	if (pDoc == NULL)
		CXmlException(1, tstring(_T("Could not load ")) + sURI);
	return pDoc;
}


xercesc::DOMDocument* CDoc::LoadFromString(const tstring& sXml)
{
	xercesc::DOMBuilder* pBuilder = GetBuilder();
	InternalErrorHandler oErrorHandler;
	pBuilder->setErrorHandler(&oErrorHandler);

	static const char gMemBufId[] = "Processing";
	xercesc::MemBufInputSource* memBufIS = new xercesc::MemBufInputSource(
			(const XMLByte*)(sXml.c_str()),
			(unsigned int)sXml.length() * sizeof(TCHAR),
			gMemBufId,
			false
			);

    xercesc::Wrapper4InputSource wrapper(memBufIS);
    xercesc::DOMDocument* pDoc = pBuilder->parse(wrapper);

	//delete memBufIS;

	pBuilder->setErrorHandler(NULL);
	oErrorHandler.ReportErrors();
	if (pDoc == NULL)
		CXmlException(1, _T("Could not load xml string"));
	return pDoc;
}


void CDoc::Save(const tstring& sURI, CNode& rNode, bool bQualified, bool bPrettyPrint)
{
	FinalizeRootElement(rNode);

	CNode::InternalAdjustPrefix(rNode.m_pDOMNode, bQualified);
	rNode.AdjustPrefix();

	xercesc::DOMWriter* pWriter = GetWriter();
	xercesc::LocalFileFormatTarget myFormatTarget(sURI.c_str());

	if (!m_sEncoding.empty())
		pWriter->setEncoding(X(m_sEncoding));

	if (bPrettyPrint &&
	    pWriter->canSetFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true))
		pWriter->setFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true);

	pWriter->writeNode(&myFormatTarget, *(rNode.m_pDOMNode->getOwnerDocument()));
}


tstring CDoc::SaveToString(CNode& rNode, bool bQualified, bool bPrettyPrint)
{
	FinalizeRootElement(rNode);
	

	CNode::InternalAdjustPrefix(rNode.m_pDOMNode, bQualified);
	rNode.AdjustPrefix();

	xercesc::DOMWriter* pWriter = GetWriter();

	if (!m_sEncoding.empty())
		pWriter->setEncoding(X(m_sEncoding));

	if (bPrettyPrint &&
	    pWriter->canSetFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true))
		pWriter->setFeature(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true);

#if defined(UNICODE) || defined(_UNICODE)
	XMLCh* szXml = pWriter->writeToString(*(rNode.m_pDOMNode->getOwnerDocument()));
	tstring sXml = XC2TS( szXml );
	xercesc::XMLString::release( &szXml );
#else
	xercesc::MemBufFormatTarget memBuf; 
	pWriter->writeNode(&memBuf, *(rNode.m_pDOMNode->getOwnerDocument())); 
	tstring sXml((const char*)memBuf.getRawBuffer()); 
#endif
	return sXml;
}


void CDoc::SetEncoding(const tstring& sEncoding)
{
	m_sEncoding = sEncoding;
}


void CDoc::SetRootElementName(const tstring& sRootElementNamespaceURI, const tstring& sRootElementName)
{
	m_sRootElementNamespaceURI = sRootElementNamespaceURI;
	m_sRootElementName = sRootElementName;
}


void CDoc::SetSchemaLocation(const tstring& sSchemaLocation)
{
	m_eSchemaType = Schema;
	m_sSchemaLocation = sSchemaLocation;
}


void CDoc::SetDTDLocation(const tstring& sDTDLocation)
{
	m_eSchemaType = DTD;
	m_sSchemaLocation = sDTDLocation;
}


void CDoc::RemoveSchemaLocation()
{
	m_eSchemaType = None;
	m_sSchemaLocation = _T("");
}


void CDoc::FinalizeRootElement(CNode& rNode)
{
	if (m_sRootElementName.empty())
	{
		throw altova::Error("Call SetRootElementName first");
	}

	xercesc::DOMDocument* pDoc = GetImplementationCore()->createDocument();

	if( m_eSchemaType == DTD )
	{
		xercesc::DOMImplementation* pDOMImpl = CDoc::GetImplementationCore();
		xercesc::DOMDocumentType* pDocType = pDOMImpl->createDocumentType(X(m_sRootElementName), X(""), X(m_sSchemaLocation));
		pDoc->appendChild(pDocType);
	}

	xercesc::DOMElement* pRootElement = pDoc->createElementNS(X(m_sRootElementNamespaceURI), X(m_sRootElementName));
	pDoc->appendChild(pRootElement);

	if( m_eSchemaType == Schema )
	{
		pRootElement->setAttribute(X("xmlns:xsi"), X("http://www.w3.org/2001/XMLSchema-instance"));

		if (m_sRootElementNamespaceURI.empty())
		{
			if (!m_sSchemaLocation.empty())
				pRootElement->setAttribute(X("xsi:noNamespaceSchemaLocation"), X(m_sSchemaLocation));
		}
		else
		{
			if (!m_sSchemaLocation.empty())
				pRootElement->setAttribute(X("xsi:schemaLocation"), X(m_sRootElementNamespaceURI + _T(" ") + m_sSchemaLocation));
		}
	}

	while (xercesc::DOMNode* pNode = rNode.m_pDOMNode->getFirstChild())
	{
		pRootElement->appendChild(pDoc->importNode(pNode, true));
		rNode.m_pDOMNode->removeChild(pNode);
	}

	xercesc::DOMNamedNodeMap* pSrcAttributes = rNode.m_pDOMNode->getAttributes();
	xercesc::DOMNamedNodeMap* pDstAttributes = pRootElement->getAttributes();
	bool bHasAttributes = pSrcAttributes->getLength() > 0;
	while (pSrcAttributes->getLength() > 0)
	{
		xercesc::DOMNode* pNode = pSrcAttributes->item(0);
		pDstAttributes->setNamedItemNS(pDoc->importNode(pNode, true));
		pSrcAttributes->removeNamedItemNS(pNode->getNamespaceURI(), pNode->getLocalName());
	}
	if( bHasAttributes )
		pRootElement->setAttribute(X("xmlns:xsi"), X("http://www.w3.org/2001/XMLSchema-instance"));	// necessary, because it is overwritten when pDstAttributes->setNamedItemNS

	DeclareNamespaces(pRootElement);

	ReleaseFragment(rNode.m_pDOMNode);
	rNode.m_pDOMNode = pRootElement;
}


void CDoc::DeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI)
{
	CNode::DeclareNamespace(pElement, sPrefix, sURI);
}


} // namespace altova
